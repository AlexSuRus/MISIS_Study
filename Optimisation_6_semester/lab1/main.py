a = 0.5
b = 2
e = 0.0001
delta = e/2

# Задаем функцию y = (x-1)^2/(x)
def f(x):
    y=(x-1)**2 / (x)
    return y

def uniform_search(f, a, b, e):
    """
    Метод равномерного поиска
    f: унимодальная функция одной переменной
    a, b: границы отрезка поиска
    e: точность
    """
    delta = e / 2.0  # задаем дельту, которая равна половине точности
    i = 0
    j = 0
    while (b - a) > e:  # пока длина отрезка больше точности
        i += 1
        j += 1
        x1 = (a + b - delta) / 2.0  # вычисляем первую точку деления отрезка
        x2 = (a + b + delta) / 2.0  # вычисляем вторую точку деления отрезка
        if f(x1) <= f(x2):  # если значение функции в первой точке меньше или равно значению функции во второй точке
            b = x2  # смещаем правую границу на вторую точку деления
            j += 1
        else:
            a = x1  # иначе смещаем левую границу на первую точку деления
            j += 1
    x_min = (a + b) / 2.0  # определяем координату минимума
    f_min = f(x_min)  # определяем значение функции в точке минимума
    return x_min, f_min, i, j


def dichotomy_method(f, a, b, e):
    # Вычисляем середину интервала
    c = (a + b) / 2
    i = 0
    j = 0
    # Пока интервал больше заданной точности
    while abs(b - a) > e:
        i += 1
        j += 1
        # Вычисляем две точки, лежащие по разные стороны от середины интервала
        x1 = (a + c) / 2
        x2 = (c + b) / 2
        # Если значение функции в точке x1 меньше/больше, чем значение функции в точке x2,
        # то минимум/максимум находится в левой половине интервала [a, c]
        if f(x1) < f(x2):
            j += 1
            b = c
            c = x1
        # Иначе минимум/максимум находится в правой половине интервала [c, b]
        else:
            j += 1
            a = c
            c = x2
    # Возвращаем найденное значение аргумента и значение функции в точке минимума/максимума
    return (a + b) / 2, f((a + b) / 2), i, j


def fibonacci_method(f, a, b, e, delta):
    # Инициализация счетчиков
    j = 2  # число вычислений функции
    i = 0  # число итераций метода Фибоначчи

    # Вычисление чисел Фибоначчи
    fib = [1, 1]
    while (b - a) / e > fib[-1]:
        fib.append(fib[-1] + fib[-2])
        i += 1

    # Определение значения N
    n = len(fib) - 1

    # Вычисление начальных значений
    x1 = a + fib[n - 2] / fib[n] * (b - a)
    x2 = a + fib[n - 1] / fib[n] * (b - a)
    f1 = f(x1)
    f2 = f(x2)

    # Итерационный процесс
    for i in range(n - 2):
        if f1 > f2:
            a = x1
            x1 = x2
            f1 = f2
            x2 = a + fib[n - 2 - i] / fib[n - 1 - i] * (b - a)
            f2 = f(x2)
            j += 1
        else:
            b = x2
            x2 = x1
            f2 = f1
            x1 = a + fib[n - 3 - i] / fib[n - 1 - i] * (b - a)
            f1 = f(x1)
            j += 1

        # Проверка условия выхода
        if (b - a) < e:
            break

    # Добавляем константу различимости
    x_min = (a + b) / 2
    x1 = x_min - delta
    x2 = x_min + delta

    # Определяем оптимальное решение
    if f(x1) > f(x2):
        x_min = x1
    else:
        x_min = x2

    return x_min, f(x_min), i, j

